/* Options */
options
{
	JAVA_UNICODE_ESCAPE = true;
	IGNORE_CASE = true;
}

/* User Code */
PARSER_BEGIN(LexicalAnalyser)
public class LexicalAnalyser {
	public static void main(String[] args) {
		LexicalAnalyser parser;
		try {
			parser = new LexicalAnalyser(new java.io.FileInputStream(args[0]));
		} catch (java.io.FileNotFoundException e) {
			System.err.println("File " + args[0] + " not found.");
			return;
		}

		for(Token t = getNextToken(); t.kind != EOF; t = getNextToken()) {
			System.out.println(t.image);
		}
	}
}
PARSER_END(LexicalAnalyser)

/* Token definitions */
SKIP: /* Skips newlines/tabs/comments etc */
{
	" " |
	"\t" |
	"\n" |
	"\r" |
	<"--" (~["\n","\r"])* ("\n" | "\r" | "\r\n")> |
	<"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

/* Keywords */
TOKEN:
{
	<AND : "and"> |
		<BOOL : "bool"> |
		<CONST : "const"> |
		<DO : "do"> |
		<ELSE : "else"> |
		<FALSE : "false"> |
		<IF : "if"> |
		<INT : "int"> |
		<MAIN : "main"> |
		<NOT : "not"> |
		<OR : "or"> |
		<REAL : "real"> |
		<RETURN : "return"> |
		<STRING : "string"> |
		<THEN : "then"> |
		<TRUE : "true"> |
		<VAR : "var"> |
		<VOID : "void"> |
		<WHILE : "while"> |
		<BEGIN: "begin"> |
		<END: "end">
}

/* Identifiers */
TOKEN:
{
	<#LETTER: ["a"-"z", "A"-"Z"]> |
	<#CHAR: ["a"-"z", "A"-"Z", "0"-"9", "_"]> |
	<ID: (<LETTER>)(<CHAR>)+> |
	<#DIGIT : "[0-9]"> |
	<#TNUM: "<DIGIT>+"> |
	<#DEC: "<NUM>*.<NUM>"> |
	<NUM: <DEC> | <TNUM>>
}

/* Comnparirson Operators */
TOKEN:
{
	<EQ: "=">     |
	<NOTEQ: "!="> |
	<LTE: ">=">   |
	<GTE: "<=">   |
	<GT: ">">     |
	<LT: "<">
}

/* Operators */
TOKEN:
{
	<PLUS: "+"> |
	<SUB: "-">  |
	<MULT: "*"> |
	<DIV: "/"> 
}

/* Punctuation */
TOKEN: 
{
	<COMMA: ",">      |
	<SEMI_COLON: ";"> |
	<COLON: ":">      |
	<PERCENT: "%">    |
	<DOT: ".">        |
	<QMARK: "?">      |
	<EXLMARK: "!">    |
	<ASSIGN: ":=">
}

/* Braces */
TOKEN:
{
	<LPAREN: "("> |
	<RPAREN: ")">
}

/* Empty String */
TOKEN:
{
	<EPSILON: "">
}

TOKEN:
{
	<ERR: ~[]>
}

void Program() : {} {
	(Decl())*(Function())*MainProg()
}

void Decl() : {} {
	(VarDecl() | ConstDecl())
}

void VarDecl() : {} {
	<VAR>IndentList()<COLON>Type()(<COMMA> IndentList()<COLON>Type())*<SEMI_COLON>
}

void ConstDecl() : {} {
	<CONST>Identifier()<COLON>Type()<EQ>Expression()(<COMMA> Identifier()<COLON>Type()<EQ>Expression())*<SEMI_COLON>
}

void Function() : {} {
//	Type()Identifier() eh?
	<AND>
}

void ParamList() : {} {
	(Identifier()<COLON>Type()(<COMMA>Identifier()<COLON>Type())* | <EPSILON>)
}

void Type() : {} {
		<INT> | <BOOL> | <VOID>
}

void MainProg() : {} {
	<MAIN><BEGIN>(Decl())*(Statement()<SEMI_COLON>)*<END>
}

void Statement() : {} {
	Identifier()<ASSIGN>Expression() |
	Identifier()(ArgList()) |
	<BEGIN>(Statement()<SEMI_COLON>)*<END> |
	<IF>Condition()<THEN>Statement()<SEMI_COLON><ELSE>Statement() |
	<WHILE>Condition()<DO>Statement() |
	<EPSILON>
}

void Expression() : {} {
	Fragment()((<AND> | <SUB> | <MULT> | <DIV>) Fragment())* | //here
	(Expression()) |
	Identifier()(ArgList())
}

void Fragment() : {} {
	Identifier() |
	<TRUE> |
	<FALSE> |
	<NUM> |
	(<PLUS> | <SUB>)Fragment() |
	Expression()
}

void Condition() : {} { //here
	<NOT>Condition() |
	Expression()(<EQ> | <NOTEQ> | <LT> | <GT> | <LTE> | <GTE>)Expression() |
	Condition()(<AND> | <OR>)Condition() |
	Identifier()(ArgList())
}

void IndentList() : {} {
	Identifier()(<COMMA> Identifier())*
}

void ArgList() : {} {
	Identifier() (<COMMA> Identifier())* |
	<EPSILON>
}

void Identifier() : {} {
	<ID>
}
